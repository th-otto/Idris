!begin_node IDRIS System Interface
!html_name idris_system_interface

!toc !depth 1

################################################################################

!begin_node Idris system interface
!html_name system_interface

!begin_blist [NAME]
!item [NAME] (!nl)
Interface - Idris system interface

!item [FUNCTION] (!nl)
The functions in this section define the Idris system interface that is
visible to a C program, regardless of target machine. It is actually the
union of two interfaces:

!begin_enumerate
!item the standard portable C system interface, as documented in Section
III of the C Programmers' Manual, and
!item the system calls supported by all Idris implementations, provided
as C callable functions. Each Idris Interface Manual describes the
actual machine level system call formats for a given target machine.
!end_enumerate

!subheading TYPES
A number of special data types are used to help document the Idris system
interface. The more heavily used of these are defined in the standard
system header file sys.h. The special types are:

!begin_blist [DEV]
!item [DEV]
an unsigned short integer, whose more significant byte is the "major
number" of a physical device and whose less significant byte is the
"minor number". The major number is used to index into one of two
resident device tables (for block special or character special devices)
to select a device handler. The device number DEV is tucked in an odd
corner of a block or character special inode, is provided as part of
the file status delivered up for stat (or fstat), and is passed to the
selected device handler in case it deals with multiple devices. Note
that a device number is written on disk less significant byte first,
regardless of target machine.
!item [DIR]
a directory link entry, consisting of a two-byte inode number and a
14-byte link name. No system call delivers up a DIR, but such creatures
are frequently read when scanning directories. Note that the inode
number is written on disk less significant byte first, regardless of
target machine. Defined in <sys.h>.
!item [ERROR]
a short integer, capable of holding any error return code from the
resident. Zero or a positive number usually indicates success; Idris
error code is usually negated. Defined in <sys.h>.
!item [PID]
a short integer, capable of holding any processid. Valid processids
are always positive, nonzero.
!item [SIG]
a character, capable of holding any signal.
!item [STAT]
the file status returned by the fstat or stat system calls. Defined
in <sys/stat.h> and described along with fstat.
!item [TTY]
the tty status returned by gtty and expected by stty. Defined in
<sys.h> and described along with gtty.
!item [UID]
an unsigned character* capable of holding any userid or groupid.
!end_blist

Extensive use is also made of two more conventional C types:
!begin_blist [FILE]
!item [FILE]
a short integer, capable of holding a negated error code or any valid
file descriptor returned by Idris.
!item [TEXT *]
a pointer to character, usually to the first of a NUL-terminated string
of characters variously known as a string, filename, or path name. Note
that this declaration is sometimes used merely to indicate a pointer
with unknown storage boundary constraints, as an ar bitrary user memory
address.
!item [ERROR]

An important group of system parameters is the error codes. These are
returned, when a system call fails, to indicate the general nature of the
failure. Most system calls can return a variety of error codes, and most
error codes can be returned by a variety of system calls, so no attempt is
made to correlate the two groups. The error codes are:

!begin_itemize !compressed
!item E2BIG (7) argument list too big for exec.
!item EACCES (13) file access prohibited.
!item EAGAIN (11) exec or fork failed* but may work if you try again.
!item EBADF (9) bad file descriptor.
!item EBUSY (16) can't mount or unmount busy filesystem.
!item ECHILD (10) no children to wait for.
!item EDOM (33) math function argument outside defined domain.
!item EEXIST (17) file already exists.
!item EFAULT (11) can't access argument on system call.
!item EFBIG (27) file too big.
!item EINTR (1) system call was interrupted.
!item EINVAL (22) illegal argument value on system call.
!item EIO (5) unrecoverable physical I/O error.
!item EISDIR (21) file is a directory.
!item EMFILE (21) too many files opened by process.
!item EMLINK (31) too many links to a file.
!item ENFILE (23) no system storage left to represent opened file.
!item ENODEV (19) not a defined operation for the device.
!item ENOENT (2) directory entry does not exist.
!item ENOEXEC (8) wrong file format for exec.
!item ENOMEM (12) not enough memory to exec program or to grow heap.
!item ENOSPC (28) no space on filesystem.
!item ENOTBLK (15) not a block special device.
!item ENOTDIR (20) not a directory.
!item ENOTTY (25) not a tty.
!item ENXIO (6) nonexistent I/O device.
!item EPERM (1) user lacks permission.
!item EPIPE (32) write to broken pipe.
!item ERANGE (34) math function result outside representable range.
!item EROFS (30) readronly filesystera.
!item ESPIPE (29) can't seek on a pipe.
!item ESRCH (3) can't find process to signal.
!item ETXTBSY (26) shared text portion of file is in use by exec.
!item EXDEV (18) can't link across filesystems.
!end_itemize

!end_blist

!item [SIGNALS] (!nl)
There are also a number of signals that can be sent to processes, for standard
system action or for handling by the program itself. These are:

!begin_itemize !compressed
!item SIGALRM (14) alarm clock timeout.
!item SIGBUS (10) bus error, as for nonexistent memory.
!item SIGDOM (7) domain error for a math function.
!item SIGFPT (8) floating point arithmetic error.
!item SIGHUP (1) hangup, as when dataphone disconnects.
!item SIGILIN (4) illegal instruction.
!item SIGINT (2) interrupt, as when DEL is typed.
!item SIGKILL (9) kill request.
!item SIGPIPE (13) broken pipe.
!item SIGQUIT (3) quit, as when ctl-\ is typed.
!item SIGRNG (6) range error for a math function.
!item SIGSEG (11) segmentation, or memory protection, violation.
!item SIGSYS (12) bad system call.
!item SIGTERM (15) terminate request, a catchable variant of kill.
!item SIGTRC (5) instruction execution trace.
!end_itemize

Along with the signals is defined the special user memory address: NOSIG (1)
signal is to be ignored.

NOSIG is to be distinguished from the other special pointer value, NULL, which
calls for standard system handling of a signal. Any other pointer value is
used as the address of a function to handle the signal in question. See the
manual page on signal for more information.

!item [BUGS] (!nl)
All of the types used in this section should appear in <sys.h>.

!end_blist

!end_node

################################################################################

!begin_node Conventions
!html_name conventions

!begin_blist [NAME]
!item [NAME] (!nl)
Conventions - Idris system subroutines

!item [SYNOPSIS] (!nl)
 #include <sys.h>

!item [FUNCTION] (!nl)
All standard system library functions callable from C follow a set of
uniform conventions, many of which are supported at compile time by
including a standard header file, <sys.h>, at the top of each program.
Note that this header is used in addition to the standard header
<std.h>. The system header defines various system parameters and a
useful macro or two.

Herewith the principal definitions:

!begin_itemize !compressed
!item DIRSIZE - m, the maximum directory name size
!item E2BIG - 7, the error codes returned by system calls
!item EACCES - 13
!item EAGAIN - 11
!item EBADF - 9
!item EBUSY - 16
!item ECHILD - 10
!item EDOM - 33
!item EEXIST - 17
!item EFAULT - 11
!item EFBIG - 27
!item EINTR - 1
!item EINVAL - 22
!item EIO - 5
!item EISDIR - 21
!item EMFILE - 21
!item EMLINK - 31
!item ENFILE - 23
!item ENODEV - 19
!item ENOENT - 2
!item ENOEXEC - 8
!item ENOMEM - 12
!item ENOSPC - 28
!item ENOTBLK - 15
!item ENOTDIR - 20
!item ENOTTY - 25
!item ENXIO - 6
!item EPERM - 1
!item EPIPE - 32
!item ERANGE - 31
!item EROFS - 30
!item ESPIPE - 29
!item ESRCH - 3
!item ETXTBSY - 26
!item EXDEV - 18
!item NAMSIZE - 61, the maximum filename size, counting NUL at end
!item NSIG - 16, the number of signals, counting signal 0
!item SIGALRM - 11, the signal numbers
!item SIGBUS - 10
!item SIGDOM - 7
!item SIGFPT - 8
!item SIGHUP - 1
!item SIGILIN - 4
!item SIGINT - 2
!item SIGKILL - 9
!item SIGPIPE - 13
!item SIGQUIT - 3
!item SIGRNG - 6
!item SIGSEG - 11
!item SIGSYS - 12
!item SIGTERM - 15
!item SIGTRC - 5
!end_itemize

The macro isdir(mod) is a boolean rvalue that is true if the mode mod,
obtained by a getmod call, is that of a directory. Similarly isblk(mod)
tests for block special devices, and ischr(mod) tests for character
special devices.

!end_blist

!end_node

################################################################################

!begin_node _pname - program name
!ignore_index
!label _pname
!html_name _pname

!begin_blist [NAME]
!item [NAME] (!nl)
_pname - program name

!item [SYNOPSIS] (!nl)
TEXT *_pname;

!item [FUNCTION] (!nl)
_pname is the (NUL terminated) name by which the program was invoked,
as obtained from the command line argument zero. It overrides any name
supplied by the program at compile time.

It is used primarily for labelling diagnostic printouts.

!end_blist

!end_node

################################################################################

!begin_node brk - set system break to address
!ignore_index
!label brk
!html_name brk

!begin_blist [NAME]
!item [NAME] (!nl)
brk - set system break to address

!item [SYNOPSIS] (!nl)
TEXT *brk(addr) (!nl)
~~~~TEXT *addr;

!item [FUNCTION] (!nl)
brk sets the system break, at the top of the data area, to addr.
Addresses between the system break and the current top of stack are not
considered part of the valid process image; they may or may not be
preserved. It is considered an error for the top of stack ever to
extend below the system break.

!item [RETURNS] (!nl)
If successful, brk returns the old system break; otherwise the value
returned is -1.

!item [EXAMPLE] (!nl)
!begin_sourcecode
if (brk(end + nsyms ? sizeof (symbol)) == -1)
{
putstr(STDERR, "not enough room!\n", NULL);
exit(NO);
}
!end_sourcecode

!item [SEE ALSO] (!nl)
sbreak

!end_blist

!end_node

################################################################################

!begin_node chdir - change working directory
!ignore_index
!label chdir
!html_name chdir

!begin_blist [NAME]
!item [NAME] (!nl)
chdir - change working directory

!item [SYNOPSIS] (!nl)
ERROR chdir(fname) (!nl)
~~~~TEXT *fname;

!item [FUNCTION] (!nl)
chdir changes the working directory to fname.

!item [RETURNS] (!nl)
chdir returns zero if successful, else a negative number, which is the
Idris error return code, negated.

!item [EXAMPLE] (!nl)
!begin_sourcecode
chdir("/tmp");
!end_sourcecode

!end_blist

!end_node

################################################################################

!begin_node chmod - change mode of file
!ignore_index
!label chmod
!html_name chmod

!begin_blist [NAME]
!item [NAME] (!nl)
chmod - change mode of file

!item [SYNOPSIS] (!nl)
ERROR chmod(fname, mode) (!nl)
~~~~TEXT *fname; (!nl)
~~~~BITS mode;

!item [FUNCTION] (!nl)
chmod changes the mode of the file fname to match mode. Only the low
order twelve bits of mode are used, to specify ugtrwxrwxrwx, where u is
the set userid bit, g is the set groupid bit, t is the save text image
bit, and the rwx groups give access permissions for the file. Access
per missions are r for read, w for write, and x for execute (or scan
permission for a directory); the first group applies to the owner of
the file, the second to the group that owns the file, and the third to
the hoi polloi.

!item [RETURNS] (!nl)
chmod returns zero if successful, else a negative number,
which is the Idris error return code, negated.

!item [EXAMPLE] (!nl)
To make a file executable:
!begin_sourcecode
chmod("xeq", 0777);
!end_sourcecode

!item [SEE ALSO] (!nl)
getmod

!end_blist

!end_node

################################################################################

!begin_node chown - change owner of file
!ignore_index
!label chown
!html_name chown

!begin_blist [NAME]
!item [NAME] (!nl)
chown - change owner of file

!item [SYNOPSIS] (!nl)
ERROR ERROR chown(fname, owner) (!nl)
~~~~TEXT *fname; (!nl)
~~~~UCOUNT owner;

!item [FUNCTION] (!nl)
chown changes the owner of file fname to be the less significant byte of
owner, and changes its group to be the more significant byte of owner.
Only the superuser succeeds with this call,

!item [RETURNS] (!nl)
chown returns zero if successful, else a negative number, which is the
Idris error return code, negated.

!item [EXAMPLE] (!nl)
To give ownership of a file to the person who invoked you:
!begin_sourcecode
chown(newfile, getuid(), getgid() << 8);
!end_sourcecode

!item [SEE ALSO] (!nl)
getgid, getuid

!end_blist

!end_node

################################################################################

!begin_node close - close a file
!ignore_index
!label close
!html_name close

!begin_blist [NAME]
!item [NAME] (!nl)
close - close a file

!item [SYNOPSIS] (!nl)
ERROR close(fd) (!nl)
~~~~FILE fd;

!item [FUNCTION] (!nl)
close closes the file associated with the file descriptor
fd, making fdavailable for future open or create calls.

!item [RETURNS] (!nl)
close returns zero, if successful, or a negative number, which is the
Idris error return code, negated.

!item [EXAMPLE] (!nl)
To copy an arbitrary number of files:
!begin_sourcecode
while (0 < ac && 0 <= (fd = open(av[?ac], READ, 0)})
{
while (0 < (n = read(fd, buf, BUFSIZE)))
    write(STDOUT, buf, n);
close(fd);
}
!end_sourcecode

!item [SEE ALSO] (!nl)
creat, open, remove, uniqnm

!end_blist

!end_node

################################################################################

!begin_node creat - make a new file
!ignore_index
!label creat
!html_name creat

!begin_blist [NAME]
!item [NAME] (!nl)
creat - make a new file

!item [SYNOPSIS] (!nl)
FILE creat(fname, perm) (!nl)
~~~~TEXT *fname; (!nl)
~~~~BITS perm;

!item [FUNCTION] (!nl)
creat makes a new file with name fname, if it did not previously exist, or
truncates the existing file to zero length. In the former case, the file
is given access permission specified by perm; in the latter, the access
permission is left unchanged. Access permissions are described under
chmod. The file is opened for writing.

!item [RETURNS] (!nl)
creat returns a file descriptor for the created file or a negative number,
which is the Idris error return code, negated.

!item [EXAMPLE] (!nl)
!begin_sourcecode
if ((fd = creat("xeq", 0777)) < 0)
    putstr(STDERR, "can't creat xeq\n", NULL);
!end_sourcecode

!item [SEE ALSO] (!nl)
chmod, close, create, open, remove, uniqnm

!end_blist

!end_node

################################################################################

!begin_node create - open an empty instance of a file
!ignore_index
!label create
!html_name create

!begin_blist [NAME]
!item [NAME] (!nl)
create - open an empty instance of a file

!item [SYNOPSIS] (!nl)
FILE create(fname, mode, rsize) (!nl)
~~~~TEXT *fname; (!nl)
~~~~COUNT mode; (!nl)
~~~~BYTES rsize;

!item [FUNCTION] (!nl)
create makes a new file with name fname, if it did not previously exist,
or truncates the existing file to zero length. An existing file has its
permissions left alone; otherwise if the filename returned by uniqnm is a
prefix of fname, the (newly created) file is given restricted access
(0600); if not, the file is given general access (0666). If (mode == 0)
the file is opened for reading, else if (mode == 1) it is opened for
writing, else (mode == 2) of necessity and the file is opened for updating
(reading and writing).

rsize is the record size in bytes, which must be nonzero on many
systems if the file is not to be interpreted as ASCII text. It is
ignored by Idris, but should be present for portability.

!item [RETURNS] (!nl)
create returns a file descriptor for the created file or a negative
number, which is the Idris error return code, negated.

!item [EXAMPLE] (!nl)
!begin_sourcecode
if ((fd = create("xeq", WRITE, 1)) < 0)
    putstr(STDERR, "can't create xeq\n", NULL);
!end_sourcecode

!item [SEE ALSO] (!nl)
close, open, remove, uniqnm

!end_blist

!end_node

################################################################################

!begin_node dup - duplicate a file descriptor
!ignore_index
!label dup
!html_name dup

!begin_blist [NAME]
!item [NAME] (!nl)
dup - duplicate a file descriptor

!item [SYNOPSIS] (!nl)
FILE dup(fd) (!nl)
~~~~FILE fd;

!item [FUNCTION] (!nl)
dup allocates a file descriptor that points at the same file, and has the
same current offset, as the file descriptor fd. It is promised that the
smallest available file descriptor is allocated on any creat, dup, open,
or pipe call, so file descriptors can be rearranged by judicious use of
dup and close calls.

!item [RETURNS] (!nl)
dup returns the newly allocated file descriptor or a negative number,
which is the Idris error return code, negated.

!item [EXAMPLE] (!nl)
To redirect STDIN from fd:
!begin_sourcecode
close(STDIN);
dup(fd);
close(fd);
!end_sourcecode

!item [SEE ALSO] (!nl)
close, creat, create, open, pipe

!end_blist

!end_node

################################################################################

# FIXME: belongs to support library
!begin_node execl - execute a file with argument list
!ignore_index
!label execl
!html_name execl

!begin_blist [NAME]
!item [NAME] (!nl)
execl - execute a file with argument list

!item [SYNOPSIS] (!nl)
ERROR execl(fname, s0, s1, ..., NULL) (!nl)
~~~~TEXT *fname, *s0, *s1, ...;

!item [FUNCTION] (!nl)
execl invokes the executable program file fname and passes it the NULL
terminated list of string arguments specified in the argument list sO,
si, etc. The invoked file overlays the current program, inheriting all
its open files and ignored signals; the current program is forever
gone. Signals that were caught by the current program revert to system
handling.

If the set userid bit in the mode for fname is set, the effective userid
of the invoked file becomes that of the owner of the file; the effective
groupid may be changed in a similar manner by the set groupid bit. (The
save text bit is currently ignored.)

The invoked program begins execution at the start of the text section,
with the string arguments at the top of user memory, just above the stack,
i.e., on the stack is initially pushed a NULL fence, followed by pointers
to the stacked strings in reverse order, followed by a count of the number
of strings passed as arguments. Thus, for a machine with two-byte integers:
!begin_itemize !compressed
!item 0(sp) is the count of arguments, typically > 0.
!item 2(sp) points to the zeroeth argument string
!item 4(sp) points to the first argument string, etc.
!end_itemize

Note that the stack is not well conditioned for direct entry into a C
function; the C runtime startup header is usually linked at the start
of the text section. It enforces conventions such as setting _pname,
isolating the execution search path, calling the C main function, and
calling exit. Note also that the fence, placed at the end of the
stacked argument strings, is -1 under UNIX/V6, and not NULL.

By convention, the zeroeth argument is always present and is taken as
the name _pname by which the file is invoked; if it contains a vertical
bar '|', the string before the first vertical bar is taken as argument
zero and the string after that bar is taken as a search path, or
concatenation of filename prefixes separated by vertical bars, used for
locating ex ecutable files. Additional arguments are typically
optional; their interpretation is left purely to the whim of the
invoked program.

!item [RETURNS] (!nl)
execl will return only if the file cannot be invoked, in which case the
value returned is the Idris error return code, negated. Specifically,
E2BIG means that too many argument characters are being sent, ENOMEM means
that the program is too large for available memory, and ENOEXEC means that
the program has execute permission but is not a proper binary object module.

!item [EXAMPLE]
!begin_sourcecode
execl("/bin/mv", file, direc, NULL);
putstr(STDERR, "can't exec mv\n", NULL);
exit(NO);
!end_sourcecode

!item [SEE ALSO] (!nl)
_pname, execv, exit, fork

!item [BUGS] (!nl)
Only 512 characters of argument strings may be sent, counting terminating
NULs.

!end_blist

!end_node

################################################################################

# FIXME: belongs to support library
!begin_node execv - execute a file with argument vector
!ignore_index
!label execv
!html_name execv

!begin_blist [NAME]
!item [NAME] (!nl)
execv - execute a file with argument vector

!item [SYNOPSIS] (!nl)
COUNT execv(fname, args) (!nl)
~~~~TEXT *fname, **args;

!item [FUNCTION] (!nl)
execv invokes the executable program file fname and passes it the NULL
terminated list of string arguments specified in the vector args. Its
behavior is otherwise identical to execl.

!item [RETURNS] (!nl)

!item [EXAMPLE]
!begin_sourcecode
avec[0] = "mv";
avec[1] = file;
avec[2] = direc;
avec[3] = NULL;
execv("/bin/mv", avec);
putstr(STDERR, "can't exec mv\n", NULL);
exit(NO);
!end_sourcecode

!item [SEE ALSO] (!nl)
execl

!end_blist

!end_node

################################################################################

!begin_node exit - terminate program execution
!ignore_index
!label exit
!html_name exit

!begin_blist [NAME]
!item [NAME] (!nl)
exit - terminate program execution

!item [SYNOPSIS] (!nl)
VOID exit(exitcode) (!nl)
~~~~int exitcode;

!item [FUNCTION] (!nl)
exit calls all functions registered with onexit, then terminates program
execution. exitcode is passed to the invoker, with the convention of 0
for successful termination.

!item [RETURNS] (!nl)
exit will never return to the caller.

!item [EXAMPLE] (!nl)
!begin_sourcecode
if ((fd = open("file", READ)) < 0)
{
putstr(STDERR, "can't open file\n", NULL);
exit(1);
}
!end_sourcecode

!item [SEE ALSO] (!nl)
onexit

!end_blist

!end_node

################################################################################

!begin_node fork - create a new process
!ignore_index
!label fork
!html_name fork

!begin_blist [NAME]
!item [NAME] (!nl)
fork - create a new process

!item [SYNOPSIS] (!nl)
PID fork()

!item [FUNCTION] (!nl)

fork creates a new process which is identical to the initial process,
except for the value returned. All open files and all signal settings
are the same in both processes. It is customary for the child process
to invoke a program file via execl or execv, shortly after birth,
while the parent either waits to learn the termination status of the
child or proceeds on to other matters.

!item [RETURNS] (!nl)
In the child process, fork returns a zero. In the parent process, fork
returns the processid of the child if successful, or a negative number,
which is the Idris error return code, negated. Failure occurs only if the
system is out of resident heap space or (possibly) out of swap space.

!item [EXAMPLE] (!nl)
!begin_sourcecode
if ((pid = forkO) < 0)
    putstrCSTDERR, "try again\n", NULL);
else if (pid)
    while (wait(&status) != pid)
        ;
else
{
    execl("prog", "prog", NULL);
    putstr(STDERR, "can't exec prog\n", NULL);
    exit(1);
}
!end_sourcecode

!item [SEE ALSO] (!nl)
execl, execv, wait

!item [BUGS] (!nl)
If the parent never waits, the dead child will remain a zombie until the
parent dies. A prolific parent can thus overpopulate the system.

!end_blist

!end_node

################################################################################

!begin_node fstat - get status of open file
!ignore_index
!label fstat
!html_name fstat

!begin_blist [NAME]
!item [NAME] (!nl)
fstat - get status of open file

!item [SYNOPSIS] (!nl)
ERROR fstat(fd, buf) (!nl)
~~~~FILE fd; (!nl)
~~~~struct stat *buf;

!item [FUNCTION] (!nl)
fstat obtains the status of the opened file fd in the structure pointed
to by buf. The structure is essentially that of a filesystem inode,
preceded by the device dev and the inode number ino on that device. The
less signicant byte of dev is the device minor number, the more
significant byte is its major number,

mode takes the form 'azzlugtrwxrwxrwx', where a is set to indicate that
the file is allocated, zz is 00 for a plain file, 01 for character
special, 10 for a directory, and 11 for block special, l is set for a
large (4096 <= size) file. 

nlinks counts the number of directory entries that point at this inode.
uid is the userid of the owner, and gid is the groupid of the owning
group. The size of the file in bytes is ((LONG)msize << 16) + lsize,

For character and block special files, addr[0] contains the device major
and minor numbers, the latter in the less significant byte. The eight
block addresses are otherwise magic from the standpoint of most users.

The last accessed time, actime, and last modified time, modtime, are both
in seconds from the 1 Jan 1970 epoch,

!item [RETURNS] (!nl)
fstat returns zero if successful, or a negative number, which is the Idris
error return code, negated,

!item [EXAMPLE]
!begin_sourcecode
if (fstat(STDIN, &sbuf) < 0 || buf.dev != dev)
    putstr(STDERR, "wrong filesystem\n", NULL);
!end_sourcecode

!item [SEE ALSO] (!nl)
chmod, getmod, stat

!end_blist

!end_node

################################################################################

!begin_node getcsw - get console switches
!ignore_index
!label getcsw
!html_name getcsw

!begin_blist [NAME]
!item [NAME] (!nl)
getcsw - get console switches

!item [SYNOPSIS] (!nl)
BYTES getcsw()

!item [FUNCTION] (!nl)
getcsw reads the console switches.

!item [RETURNS] (!nl)
getcsw always succeeds in reading the console switches, even if they don't
exist.

!item [EXAMPLE]
!begin_sourcecode
if (getcsw() == 0173030)
    sync();
!end_sourcecode

!item [BUGS] (!nl)
Many systems have no console switches in real life.

!end_blist

!end_node

################################################################################

!begin_node getegid - get effective groupid
!ignore_index
!label getegid
!html_name getegid

!begin_blist [NAME]
!item [NAME] (!nl)
getegid - get effective groupid

!item [SYNOPSIS] (!nl)
UID getegid()

!item [FUNCTION] (!nl)
getegid obtains the current effective groupid.

!item [RETURNS] (!nl)
getegid always returns the effective groupid.

!item [EXAMPLE] (!nl)
To forget who invoked you:
!begin_sourcecode
setgid(getegid());
!end_sourcecode

!item [SEE ALSO] (!nl)
getgid, setgid

!end_blist

!end_node

################################################################################

!begin_node geteuid - get effective userid
!ignore_index
!label geteuid
!html_name geteuid

!begin_blist [NAME]
!item [NAME] (!nl)
geteuid - get effective userid

!item [SYNOPSIS] (!nl)
UID geteuid()

!item [FUNCTION] (!nl)
geteuid obtains the current effective userid.

!item [RETURNS] (!nl)
geteuid always returns the effective userid.

!item [EXAMPLE] (!nl)
To forget who invoked you:
!begin_sourcecode
setuid(geteuid());
!end_sourcecode

!item [SEE ALSO] (!nl)
getuid, setuid

!end_blist

!end_node

################################################################################

!begin_node getgid - get real groupid
!ignore_index
!label getgid
!html_name getgid

!begin_blist [NAME]
!item [NAME] (!nl)
getgid - get real groupid

!item [SYNOPSIS] (!nl)
UID getgid()

!item [FUNCTION] (!nl)
getgid obtains the current real groupid.

!item [RETURNS] (!nl)
getgid always returns the real groupid.

!item [EXAMPLE] (!nl)
To revert ownership to whoever invoked you:
!begin_sourcecode
setgid(getgid());
!end_sourcecode

!item [SEE ALSO] (!nl)
getegid, setgid

!end_blist

!end_node

################################################################################

!begin_node getmod - get mode of file
!ignore_index
!label getmod
!html_name getmod

!begin_blist [NAME]
!item [NAME] (!nl)
getmod - get mode of file

!item [SYNOPSIS] (!nl)
BITS getmod(fname) (!nl)
~~~~TEXT *fname;

!item [FUNCTION] (!nl)
getmod obtains the mode of the file fname. The low order twelve bits of
mode are used to specify access permissions as described for chmod.

!item [RETURNS] (!nl)
getmod returns the (always non zero) mode of the file if successfult else
zero.

!item [EXAMPLE] (!nl)
To copy the mode of a file:
!begin_sourcecode
chmod(newfile, getmod(oldfile));
!end_sourcecode

!item [SEE ALSO] (!nl)
chmod

!end_blist

!end_node

################################################################################

!begin_node getpid - get processld
!ignore_index
!label getpid
!html_name getpid

!begin_blist [NAME]
!item [NAME] (!nl)
getpid - get processld

!item [SYNOPSIS] (!nl)
PID getpid()

!item [FUNCTION] (!nl)
getpid obtains the processid of the currently running process, which is
not very meaningful but has the virtue of being unique among all living
processes. Hence it serves as a useful seed for temporary filenames.

!item [RETURNS] (!nl)
getpid returns the (always positive) processid.

!item [EXAMPLE]
!begin_sourcecode
name[itob(name, getpidO, 10)] = '\0';
fd = create(name, WRITE);
!end_sourcecode

!item [SEE ALSO] (!nl)
uniqnm

!end_blist

!end_node

################################################################################

!begin_node getuid - get real userid
!ignore_index
!label getuid
!html_name getuid

!begin_blist [NAME]
!item [NAME] (!nl)
getuid - get real userid

!item [SYNOPSIS] (!nl)
UID getuid()

!item [FUNCTION] (!nl)
getuid obtains the current real userid.

!item [RETURNS] (!nl)
getuid always returns the real userid.

!item [EXAMPLE] (!nl)
To revert ownership to whoever invoked you:
!begin_sourcecode
setuid(getuid()):
!end_sourcecode

!item [SEE ALSO] (!nl)
geteuid, setuid

!end_blist

!end_node

################################################################################

!begin_node gtty - get tty status
!ignore_index
!label gtty
!html_name gtty

!begin_blist [NAME]
!item [NAME] (!nl)
gtty - get tty status

!item [SYNOPSIS] (!nl)
ERROR gtty(fd, buf) (!nl)
~~~~FILE fd; (!nl)
~~~~struct sgtty *buf;

!item [FUNCTION] (!nl)
gtty obtains the status of a tty or other character special device, under
control of fd, that responds to stty system calls. For a tty, six bytes
of status are returned for the character special file fd, the information
being written in the structure pointed at by buf. Other character special
devices may refuse to honor a gtty request, or they return other than six
characters, depending strongly upon the device. If the device is a tty,
the information can be interpreted as follows:
!begin_table [lll]
mask       !! value      !! meaning of speeds field
S_ISPEED   !! 0x000f     !! input speed
S_IBREAK   !! 0x0010     !! break received
S_ILOST    !! 0x0020     !! input lost (overrun)
S_IMASK4   !! 0x0040     !! reserved
S_IREADY   !! 0x0080     !! input ready to be read
S_OSPEED   !! 0x0f00     !! output speed
S_OBREAK   !! 0x1000     !! send break char
S_ONXON    !! 0x2000     !! don't output X-ON/X-OFF codes
S_0MASK4   !! 0x4000     !! reserved
S_OREADY   !! 0x8000     !! output is finished
!end_table

The input speed and output speed are codes for baudrates of the set: (0,
50, 75, 110, 131.5, 150, 200, 300, 600, 1200, 1800, 2100, 1800, 9600,
19200, 38100). A baud rate of 0 calls for the tty to hangup. By no means
do all devices support all speeds.

break received and input lost flags are reset after the gtty is done,
in put ready, if set, assures that a read of the terminal will not
readblock, output ready assures that the output queues are empty, and
that the transmitter is ready for another character, output break is
reset when the break character is sent. Since all devices cannot
generate break characters, this bit may be ignored (and left set).

erase is the character which, if typed in other than raw mode, calls for
the preceding character on the current line (if any) to be deleted. kill
is the character which calls for the entire current line to be deleted.
Defaults are '\b' (backspace) and '\25' (ctl-u). If the sign bit of
either erase or kill is set, the sequence backspace-space-backspace used
to erase characters on a CRT screen will be inhibited.

!begin_table [lll]
mask       !! value      !! meaning of mode field
M_RARE     !! 0x0001     !! rare mode
M_XTABS    !! 0x0002     !! expand tabs
M_LCASE    !! 0x0004     !! map uppercase to lowercase
M_ECHO     !! 0x0008     !! echo input
M_CRMOD    !! 0x0010     !! map carriage return to linefeed
M_RAW      !! 0x0020     !! raw mode
M_ODDP     !! 0x0040     !! generate odd parity
M_EVENP    !! 0x0080     !! generate even parity
M_NL3      !! 0x0300     !! newline delay
M_HT3      !! 0x0c00     !! horizontal tab delay
M_CR3      !! 0x3000     !! carriage return delay
M_FF1      !! 0x4000     !! form feed delay
M_BS1      !! 0x8000     !! backspace delay
!end_table

rare (the least significant bit) puts the handler in a semi-transparent
mode. DEL and FS characters cause interrupt signals, X-ON and X-OFF cause
output to start and stop, and proper parity is generated on output.
Parity bits are not removed on input.

expand tabs calls for each tab to be expanded to spaces, lease maps all
uppercase characters typed in to lowercase, and all lowercase characters
typed out to uppercase, echo steers all characters typed in back out for
full duplex operation, crmod accepts carriage returns CR as linefeeds LF,
and expands all typed out LFs to CR-LF sequences.

raw instructs the handler to ignore interpretation of input characters,
including the processing of erase and kill characters, the recognition of
interrupt codes DEL and FS, and the treatment of EOT as end of file.
Characters are read and written transparently as eight-bit bytes, with no
parity checking or mapping, and with no typeout delays.

evenp and oddp control parity generation on output. If even and odd are
off, the parity is zero. If even and odd are on, the parity is one.
Otherwise, even selects even parity and odd selects odd parity.

Various typeout delays may be requested, for newlines with nl3, horizontal
tabs with ht3, carriage returns with cr3, formfeeds and vertical tabs with
ffl, and for backspaces with bsl. Actual delays are in multiples of 1/60
second ticks. The ranges are (0, 1, 8, 12) ticks for horizontal tabs,
newlines, and carrage returns; (0, 64) for formfeeds and vertical tabs;
and (0, 16) for backspaces.

!item [RETURNS] (!nl)
gtty returns zero if successful, else a negative number which is the Idris
error return code, negated.

!item [EXAMPLE] (!nl)
To put a tty in raw mode, with minimum perturbation:
!begin_sourcecode
gtty(fd, &stat);
stat.t_mode |= M_RAW;
stty(fd, &stat);
!end_sourcecode

!item [SEE ALSO] (!nl)
stty

!end_blist

!end_node

################################################################################

!begin_node kill - send signal to a process
!ignore_index
!label kill
!html_name kill

!begin_blist [NAME]
!item [NAME] (!nl)
kill - send signal to a process

!item [SYNOPSIS] (!nl)
ERROR kill(pid, sig) (!nl)
~~~~PID pid; (!nl)
~~~~SIG signo;

!item [FUNCTION] (!nl)
kill sends the signal signo to the process identified by processid pid.
The sender must either have the same effective userid as the receiver
or be the superuser; if pid is zero, the signal is sent to all
processes under control of the same tty as the sender. A process
cannot, however, kill itself.

The signals that may be sent are:
!begin_table [lll]
NAME    !! VALUE !! MEANING
SIGHUP  !! 1     !! hangup
SIGINT  !! 2     !! interrupt
SIGQUIT !! 3     !! quit (core dump)
SIGILL  !! 4     !! illegal instruction (core dump)
SIGTRC  !! 5     !! trace trap (core dump)
SIGRNG  !! 6     !! range error (core dump)
SIGDOM  !! 7     !! domain error (core dump)
SIGFPT  !! 8     !! floating point exception (core dump)
SIGKILL !! 9     !! kill
SIGBUS  !! 10    !! bus error (core dump)
SIGSEG  !! 11    !! segmentation violation (core dump)
SIGSYS  !! 12    !! bad system call (core dump)
SIGPIPE !! 13    !! broken pipe
SIGALRM !! 14    !! alarm clock
SIGTERM !! 15    !! terminate
!end_table

A core dump may not occur on those signals that have been caught or
ignored by the receiving process. Note that SIGALRM and SIGTERM are not
defined in UNIX/V6, and that SIGRNG and SIGDOM have somewhat less
general meaning on that system.

!item [RETURNS] (!nl)
kill returns zero if successful, else a negative number which is the Idris
error return code, negated.

!item [EXAMPLE] (!nl)
To hangup a long-idle terminal (as superuser):
!begin_sourcecode
kill(pid, 1);
!end_sourcecode

!item [SEE ALSO] (!nl)
signal

!item [BUGS] (!nl)
kill is a misnomer, as it can be used to perform many other functions.

!end_blist

!end_node

################################################################################

!begin_node link - create link to file
!ignore_index
!label link
!html_name link

!begin_blist [NAME]
!item [NAME] (!nl)
link - create link to file

!item [SYNOPSIS] (!nl)
ERROR link(old, new) (!nl)
~~~~TEXT *old; (!nl)
~~~~TEXT *new;

!item [FUNCTION] (!nl)
link creates a new directory entry for a file with existing name old; the
added name is new. No checks are made for whether this is a good idea.

!item [RETURNS] (!nl)
link returns zero if successful, else a negative number, which is the
Idris error return code, negated.

!item [EXAMPLE]
!begin_sourcecode
if (link(old, new) < 0 && unlink(old) < 0)
    putstr(STDERR, "can't move file\n", NULL);
!end_sourcecode

!item [SEE ALSO] (!nl)
unlink

!item [BUGS] (!nl)
A program executing as superuser can scramble a directory structure by
injudicious calls on link.

!end_blist

!end_node

################################################################################

!begin_node lseek - set file read/write pointer
!ignore_index
!label lseek
!html_name lseek

!begin_blist [NAME]
!item [NAME] (!nl)
lseek - set file read/write pointer

!item [SYNOPSIS] (!nl)
LONG lseek(fd, offset, sense) (!nl)
~~~~FILE fd; (!nl)
~~~~LONG offset; (!nl)
~~~~COUNT whence;

!item [FUNCTION] (!nl)
lseek uses the long offset provided to modify the read/write pointer
for the file fd, under control of sense. If (sense == 0) the pointer is
set to offset, which should be positive; if (sense == 1) the offset is
algebraically added to the current pointer; otherwise (sense == 2) of
necessity and the offset is algebraically added to the length of the
file in bytes to obtain the new pointer. Idris uses only the low order
24 bits of the offset; the rest are ignored.

The call lseek(fd, 0L, 1) is guaranteed to leave the file pointer
unmodified and, more important, to succeed only if lseek calls are both
acceptable and meaningful for the fd specified. Other lseek calls may
appear to succeed, but without effect, as when rewinding a terminal.

!item [RETURNS] (!nl)
lseek returns the resulting offset location if successful, or a negative number,
which is the Idris error return code, negated.

!item [EXAMPLE] (!nl)
To read a 512-byte block:
!begin_sourcecode
BOOL getblock(buf, blkno)
TEXT *buf;
BYTES blkno;
{
    lseek(STDIN, (LONG) blkno << 9, 0);
    return (read(STDIN, buf, 512) != 512);
}
!end_sourcecode

!end_blist

!end_node

################################################################################

# disabled because that function does not exist
!if 0
!begin_node mkexec - make file executable
!ignore_index
!label mkexec
!html_name mkexec

!begin_blist [NAME]
!item [NAME] (!nl)
mkexec - make file executable

!item [SYNOPSIS] (!nl)
BOOL mkexec(fname) (!nl)
~~~~TEXT *fname;

!item [FUNCTION] (!nl)
mkexec adds "execute" permissions to the file fnarae. "Read" and "write"
permissions are left unchanged.

!item [RETURNS] (!nl)
mkexec returns YES if the file fname exists and permits its mode to be
changed. Otherwise it returns NO.

!item [EXAMPLE]
!begin_sourcecode
if (load1() && load2())
    return (mkexec(xfile));
!end_sourcecode

!item [SEE ALSO] (!nl)
chmod

!end_blist

!end_node
!endif

################################################################################

!begin_node mknod - make a special inode
!ignore_index
!label mknod
!html_name mknod

!begin_blist [NAME]
!item [NAME] (!nl)
mknod - make a special inode

!item [SYNOPSIS] (!nl)
ERROR mknod(fname, mode, dev) (!nl)
~~~~TEXT *fname; (!nl)
~~~~BITS mode; (!nl)
~~~~DEV dev;

!item [FUNCTION] (!nl)
mknod creates an empty instance of a file with pathname fname, setting
its mode bits to mode and its first address entry to dev. If (mode
0140777) for instance, the new file will be a directory with general
permissions; dev had better be zero in this case. If (mode ==
0160644), the new file will be a block special device that can be read
by all, but written only by the superuser; dev then specifies the
major/minor device numbers, the minor number in the less significant
byte.

Only the superuser may perform this call successfully.

!item [RETURNS] (!nl)
mknod returns zero if successful, else a negative number which is the
Idris error return code, negated.

!item [EXAMPLE] (!nl)
!begin_sourcecode
mknod("/dev/tty9", 0120622, major << 8 | minor);
!end_sourcecode

!end_blist

!end_node

################################################################################

!begin_node mount - mount a file system
!ignore_index
!label mount
!html_name mount

!begin_blist [NAME]
!item [NAME] (!nl)
mount - mount a file system

!item [SYNOPSIS] (!nl)
ERROR mount(spec, fname, ronly) (!nl)
~~~~TEXT *spec, fname; (!nl)
~~~~BOOL ronly;

!item [FUNCTION] (!nl)
mount associates the root of the filesystem written on the block special
device spec with the pathname fname; henceforth the mounted filesystem is
reachable via pathnames through fname. If ronly is nonzero, the
filesystem is mounted read only, i.e. all files are write protected and
access times are not updated.

name must already exist; its contents are rendered inaccessible by the
mount operation.

Only the superuser succeeds with this call.

!item [RETURNS] (!nl)
mount returns zero if successful, else a negative number which is the
Idris error return code, negated.

!item [EXAMPLE] (!nl)
!begin_sourcecode
mount("/dev/rkl", "/usr", 0);
!end_sourcecode

!item [SEE ALSO] (!nl)
umount

!end_blist

!end_node

################################################################################

!begin_node nice - set priority
!ignore_index
!label nice
!html_name nice

!begin_blist [NAME]
!item [NAME] (!nl)
nice - set priority

!item [SYNOPSIS] (!nl)
ERROR nice(pri) (!nl)
~~~~TINY pri;

!item [FUNCTION] (!nl)
nice sets the scheduling priority of the process to pri, which must be in
the range [0, 20] for all but the superuser. The higher the number, the
lower the priority [sic]; default is zero.

On some implementations, a sufficiently negative pri will lock a process
into memory, so that it is never swapped out.

!item [RETURNS] (!nl)
nice returns zero if successful, else a negative number which is the Idris
error return code, negated.

!item [EXAMPLE] (!nl)
To be polite when running a long program:
!begin_sourcecode
nice(4);
!end_sourcecode

!item [BUGS] (!nl)
nice is a misnomer, since it can be used to do unnice things.

!end_blist

!end_node

################################################################################

# FIXME: belongs to support library
!begin_node onexit - call function on program exit
!ignore_index
!label onexit
!html_name onexit

!begin_blist [NAME]
!item [NAME] (!nl)
onexit - call function on program exit

!item [SYNOPSIS] (!nl)
VOID (*onexit())(pfn) (!nl)
~~~~VOID (*(*pfn)())();

!item [FUNCTION] (!nl)
onexit registers the function pointed at by pfn, to be called on program
exit. The function at pfn is obliged to return the pointer returned by
the onexit call, so that any previously registered functions can also be
called.

!item [RETURNS] (!nl)
onexit returns a pointer to another function; it is guaranteed not to be
NULL.

!item [EXAMPLE] (!nl)
!begin_sourcecode
IMPORT VOID (*(*nextguy)())(), (*thisguy())();
if (!nextguy)
    nextguy = onexit(&thisguy);
!end_sourcecode

!item [SEE ALSO] (!nl)
exit, onintr

!item [BUGS] (!nl)
The type declarations defy description, and are still wrong.

!end_blist

!end_node

################################################################################

# FIXME: belongs to support library
!begin_node onintr - capture interrupts
!ignore_index
!label onintr
!html_name onintr

!begin_blist [NAME]
!item [NAME] (!nl)
onintr - capture interrupts

!item [SYNOPSIS] (!nl)
VOID onintr(pfn) (!nl)
~~~~VOID (*pfn)();

!item [FUNCTION] (!nl)
onintr ensures that the function at pfn is called on a broken pipe, or
on the occurrence of an interrupt (DEL key) or hangup generated from
the keyboard of a controlling terminal. Any earlier call to onintr is
overridden.

The function is called with one integer argument, whose value is always
zero, and must not return; if it does, a message is output to STDERR and
an immediate error exit is taken.

If (pfn == NULL) then these interrupts are disabled (turned off). Any
disabled interrupts are not, however, turned on by a subsequent call with
pfn not NULL.

!item [RETURNS] (!nl)
Nothing.

!item [EXAMPLE] (!nl)
A common use of onintr is to ensure a graceful exit on early termination:
!begin_sourcecode
onexit(&rmtemp);
onintr(&exit);
...
VOID rmtemp()
{
    remove(uniqnm());
}
!end_sourcecode
Still another use is to provide a way of terminating long printouts, as in
an interactive editor:
!begin_sourcecode
while (!enter(docmd, NULL))
    putstr(STDOUT, "?\n", NULL);
...
VOID docmd()
{
    onintr(&leave);
}
!end_sourcecode

!item [SEE ALSO] (!nl)
onexit

!end_blist

!end_node

################################################################################

!begin_node open - open a file
!ignore_index
!label open
!html_name open

!begin_blist [NAME]
!item [NAME] (!nl)
open - open a file

!item [SYNOPSIS] (!nl)
FILE open(fname, mode, rsize) (!nl)
~~~~TEXT *fname; (!nl)
~~~~COUNT mode; (!nl)
~~~~BYTES rsize;

!item [FUNCTION] (!nl)
open opens a file with name fname and assigns a file descriptor to it. If
(mode == 0) the file is opened for reading, else if (mode == 1) it is
opened for writing, else (mode == 2) of necessity and the file is opened
for updating (reading and writing).

rsize is the record size in bytes, which must be nonzero on many systems
if the file is not to be treated as ASCII text. It is ignored by Idris,
but should be present for portability.

!item [RETURNS] (!nl)
open returns a file descriptor for the opened file or a negative number,
which is the Idris error return code, negated.

!item [EXAMPLE]
!begin_sourcecode
if ((fd = open("xeq", WRITE, 1)) < 0)
    putstr(STDERR, "can't open xeq\n", NULL);
!end_sourcecode

!item [SEE ALSO] (!nl)
close, creat

!end_blist

!end_node

################################################################################

!begin_node pipe - setup a data pipe
!ignore_index
!label pipe
!html_name pipe

!begin_blist [NAME]
!item [NAME] (!nl)
pipe - setup a data pipe

!item [SYNOPSIS] (!nl)
FILE pipe(fds) (!nl)
~~~~FILE fds[2];

!item [FUNCTION] (!nl)
pipe sets up a pipeline, i.e. a data transfer mechanism that can be read
by one file descriptor and written by another. fds[0] is the read file
descriptor, fds[1] is the write file descriptor.

Since children spawned by fork inherit all open files, it is possible with
pipe to set up a communication link between processes having a common
parent. The pipe mechanism synchronizes reading and writing, allowing the
producer to get ahead up to 4096 bytes before being made to wait.

Reading an empty pipe with no writers left results in an end of file
return; a pipe with no readers causes a broken pipe signal and, if the
signal is ignored, causes an error return on subsequent writes.

!item [RETURNS] (!nl)
pipe writes the read file descriptor in fds[0] and the write file
descriptor in fds[1] if successful. The value of the function is fds[O]
if successful or a negative number, which is the Idris error return
code, negated.

!item [EXAMPLE] (!nl)
To hook a child to STDOUT:
!begin_sourcecode
pipe(fds);
if (pid = fork())
{
    close(STDOUT);
    dup(fds[1]);
    close(fds[0]);
    close(fds[1]);
}
else
{
    close(STDIN);
    dup(fds[O]);
    close(fds[0]);
    close(fds[l]);
    exec("child", "child", NULL);
    exit(NO);
}
!end_sourcecode

!item [SEE ALSO] (!nl)
close, creat, create, dup, execl, execv, open, read, write

!end_blist

!end_node

################################################################################

!begin_node profil - set profiler parameters
!ignore_index
!label profil
!html_name profil

!begin_blist [NAME]
!item [NAME] (!nl)
profil - set profiler parameters

!item [SYNOPSIS] (!nl)
VOID profil(buf, size, offset, scale) (!nl)
~~~~COUNT *buf; (!nl)
~~~~BYTES size, offset, scale;

!item [FUNCTION] (!nl)
profil sets the parameters used by the system for execution time profiling
of the user mode program counter. On each clock tick (60 times per
second), offset is subtracted from the user program counter and the result
multiplied by scale, which is taken as an unsigned binary fraction in the
interval [0, 1), If the result is in the interval [0, size), it is used
as an index to select the element of buf to increment.

Unlike UNIX, Idris assumes that the binary fraction is always one less
(when taken as an integer) than a power of two. That is, the resident
considers only the highest order bit set in scale, and assumes that all
bits to the right of it are ones. This difference should be transparent
to all known uses of profil.

If scale is 0, profiling is turned off.

!item [RETURNS] (!nl)
Nothing.

!item [EXAMPLE] (!nl)
To profile to a resolution of four code bytes per counter:
!begin_sourcecode
profil(buf, size, 0, ((BYTES)-1 >> 2) + 1); /* [sic] */
!end_sourcecode

!end_blist

!end_node

################################################################################

!begin_node read - read from a file
!ignore_index
!label read
!html_name read

!begin_blist [NAME]
!item [NAME] (!nl)
read - read from a file

!item [SYNOPSIS] (!nl)
COUNT read(fd, buf, size) (!nl)
~~~~FILE fd; (!nl)
~~~~TEXT *buf; (!nl)
~~~~BYTES size;

!item [FUNCTION] (!nl)
read reads up to size characters from the file specified by fd into the
buffer starting at buf.

!item [RETURNS] (!nl)
If an error occurs, read returns a negative number which is the Idris
error code, negated; if end of file is encountered, read returns zero;
otherwise the value returned is between 1 and size, inclusive.
When reading from a disk file, size bytes are read whenever possible.

!item [EXAMPLE] (!nl)
To copy a file:
!begin_sourcecode
while (0 < (n = read(STDIN, buf, BUFSIZE)))
    write(STDOUT, buf, n);
!end_sourcecode

!item [SEE ALSO] (!nl)
write

!end_blist

!end_node

################################################################################

!begin_node remove - remove a file
!ignore_index
!label remove
!html_name remove

!begin_blist [NAME]
!item [NAME] (!nl)
remove - remove a file

!item [SYNOPSIS] (!nl)
ERROR remove(fname) (!nl)
~~~~TEXT *fname;

!item [FUNCTION] (!nl)
remove deletes the file fname from the Idris directory structure. If no
other names link to the file, the file is destroyed. If the file is
opened for any reason, however, destruction will be postponed until the
last close on the file.

If the file is a directory, remove will not attempt to remove it.

!item [RETURNS] (!nl)
remove returns zero, if successful, or a negative number, which is the
Idris error return code, negated.

!item [EXAMPLE]
!begin_sourcecode
if (remove("temp.c") < 0)
    putstr(STDERR, "can't remove temp file\n", NULL);
!end_sourcecode

!item [SEE ALSO] (!nl)
creat, unlink

!end_blist

!end_node

################################################################################

# FIXME: belongs to support library
!begin_node sbreak - set system break
!ignore_index
!label sbreak
!html_name sbreak

!begin_blist [NAME]
!item [NAME] (!nl)
sbreak - set system break

!item [SYNOPSIS] (!nl)
TEXT *sbreak(size) (!nl)
~~~~BYTES size;

!item [FUNCTION] (!nl)
sbreak moves the system break, at the top of the data area, algebraically
up by size bytes, rounded up as necessary to placate memory management
hardware.

!item [RETURNS] (!nl)
If successful, sbreak returns a pointer to the start of the added data
area; otherwise the value returned is NULL.

!item [EXAMPLE]
!begin_sourcecode
if (!(p = sbreak(nsyms * sizeof (symbol)}))
{
    putstr(STDERR, "not enough room!\n", NULL);
    exit(NO);
}
!end_sourcecode

!item [SEE ALSO] (!nl)
brk

!end_blist

!end_node

################################################################################

!begin_node seek - set file read/write pointer
!ignore_index
!label seek
!html_name seek

!begin_blist [NAME]
!item [NAME] (!nl)
seek - set file read/write pointer

!item [SYNOPSIS] (!nl)
ERROR seek(fd, offset, sense) (!nl)
~~~~FILE fd; (!nl)
~~~~COUNT offset, sense;

!item [FUNCTION] (!nl)
seek uses the offset provided to modify the read/write pointer for the
file fd, under control of sense. If (sense == 0) the pointer is set to
offset, which is treated as an unsigned integer; if (sense == 1) the
offset is algebraically added to the current pointer; if (sense == 2)
the offset is algebraically added to the length of the file in bytes to
obtain the new pointer.

If (sense is between 3 and 5 inclusive), the offset is multiplied by 512L
and the resultant long offset is used with (sense - 3). Idris uses only
the low order 24 bits of the offset; the rest are ignored. Block offsets
are primarily of use in machines with short pointers.

!item [RETURNS] (!nl)
seek returns zero if successful, or a negative number, which is the Idris
error return code, negated.

!item [EXAMPLE] (!nl)
To read a 512-byte block:
!begin_sourcecode
BOOL getblock(buf, blkno)
TEXT *buf;
BYTES blkno;
{
    seek(STDIN, blkno, 3);
    return (read(STDIN, buf, 512) != 512);
}
!end_sourcecode

!item [SEE ALSO] (!nl)
lseek

!end_blist

!end_node

################################################################################

!begin_node setgid - set groupid
!ignore_index
!label setgid
!html_name setgid

!begin_blist [NAME]
!item [NAME] (!nl)
setgid - set groupid

!item [SYNOPSIS] (!nl)
ERROR setgid(gid) (!nl)
~~~~GID gid;

!item [FUNCTION] (!nl)
setgid sets the groupid, both real and effective, of the current process
to gid. Only the superuser may change the gid.

!item [RETURNS] (!nl)
setgid returns zero if successful, else a negative number which is the
Idris error return code, negated.

!item [EXAMPLE] (!nl)
To revert effective groupid back to real:
!begin_sourcecode
setgid(getgid());
!end_sourcecode

!item [SEE ALSO] (!nl)
getgid

!end_blist

!end_node

################################################################################

!begin_node setuid - set userld
!ignore_index
!label setuid
!html_name seuid

!begin_blist [NAME]
!item [NAME] (!nl)
setuid - set userld

!item [SYNOPSIS] (!nl)
ERROR setuid(uid) (!nl)
~~~~UID uid;

!item [FUNCTION] (!nl)
setuid sets the userid, both real and effective, of the current process to
uid. Only the superuser may change the uid.

!item [RETURNS] (!nl)
setuid returns zero if successful, else a negative number which is the
Idris error return code, negated.

!item [EXAMPLE] (!nl)
To revert effective userid back to real:
!begin_sourcecode
setuid(getuid());
!end_sourcecode

!item [SEE ALSO] (!nl)
getuid

!end_blist

!end_node

################################################################################

!begin_node signal - capture signals
!ignore_index
!label signal
!html_name signal

!begin_blist [NAME]
!item [NAME] (!nl)
signal - capture signals

!item [SYNOPSIS] (!nl)
VOID (*signal(sig, pfunc))() (!nl)
~~~~SIG sig; (!nl)
~~~~VOID (*pfunc)();

!item [FUNCTION] (!nl)
signal changes the handling of the signal sig according to pfunc. Legal
values of sig are described under the kill system call. If pfunc is
NULL, normal system handling occurs, i.e. the process is terminated
when the signal occurs, possibly with a core dump; if pfunc is NOSIG
(ie. 1), the signal is ignored; otherwise pfunc is taken as a pointer
to a code sequence to be entered in the user program when the signal
occurs.

Note that the code sequence may not, in general, be a C function, since
registers may not be properly saved and the stack may not be prepared
for an orderly return; to return properly to the interrupted code, a
machine dependent code sequence must often be performed. If a system
call was interrupted and the signal handler returns properly to the
interrupted code, the system call reports an abnormal termination with
the EINTR error code.

Except for illegal instruction and trace trap, all signals revert to
system handling after each occurrence; all signals revert to system
handling on an execl or execv, but not on a fork.

!item [RETURNS] (!nl)
signal returns the old pfunc if successful, else -1.

!item [EXAMPLE] (!nl)
To prevent hangups:
!begin_sourcecode
signal(1, NOSIG);
!end_sourcecode

!item [SEE ALSO] (!nl)
execl, execv, fork, kill

!end_blist

!end_node

################################################################################

!begin_node sleep - delay for awhile
!ignore_index
!label sleep
!html_name sleep

!begin_blist [NAME]
!item [NAME] (!nl)
sleep - delay for awhile

!item [SYNOPSIS] (!nl)
VOID sleep(sees) (!nl)
~~~~UCOUNT sees;

!item [FUNCTION] (!nl)
sleep suspends execution of the current process for sees seconds.

!item [RETURNS] (!nl)
sleep returns zero if successful (clock is enabled), or a negative number,
which is the Idris error return code, negated.

!item [EXAMPLE]
!begin_sourcecode
while ((fd = creat("lock", 0444)) < 0)
    sleep(5);
!end_sourcecode

!end_blist

!end_node

################################################################################

!begin_node stat - get status of named file
!ignore_index
!label stat
!html_name stat

!begin_blist [NAME]
!item [NAME] (!nl)
stat - get status of named file

!item [SYNOPSIS] (!nl)
ERROR stat(fname, buf) (!nl)
~~~~TEXT *fname; (!nl)
~~~~struct stat *buf;

!item [FUNCTION] (!nl)
stat obtains the status of the file fname in the structure pointed to by
buf. The structure is essentially that of a filesystem inode, preceded by
the device dev and the inode number ino on that device; it is described
under fstat.

!item [RETURNS] (!nl)
stat returns zero if successful, or a negative number, which is the Idris
error return code, negated.

!item [EXAMPLE]
!begin_sourcecode
if (stat(av[1], &sbuf) < 0 || !isdir(sbuf.mode))
    putstr(STDERR, av[1], " is not a directory\n", NULL);
!end_sourcecode

!item [SEE ALSO] (!nl)
chmod, fstat, getmod

!end_blist

!end_node

################################################################################

!begin_node stime - set system time
!ignore_index
!label stime
!html_name stime

!begin_blist [NAME]
!item [NAME] (!nl)
stime - set system time

!item [SYNOPSIS] (!nl)
ERROR stime(time) (!nl)
~~~~ULONG time;

!item [FUNCTION] (!nl)
stime sets the system time to time, which is the number of seconds since
the 1 Jan 1970 epoch. Only the superuser succeeds with this call.

!item [RETURNS] (!nl)
stime returns zero if successful, else a negative number which is the
Idris error return code, negated.

!item [EXAMPLE] (!nl)
To backup an hour:
!begin_sourcecode
stime(time() - 60 * 60);
!end_sourcecode

!item [SEE ALSO] (!nl)
time

!end_blist

!end_node

################################################################################

!begin_node stty - set tty status
!ignore_index
!label stty
!html_name stty

!begin_blist [NAME]
!item [NAME] (!nl)
stty - set tty status

!item [SYNOPSIS] (!nl)
ERROR stty(fd, buf) (!nl)
~~~~FILE fd; (!nl)
~~~~struct sgtty *buf;

!item [FUNCTION] (!nl)
stty sets the status of a tty or other character special device under
control of the file descriptor fd, to the values in the structure pointed
at by buf. The structure is the same as described under gtty.

!item [RETURNS] (!nl)
stty returns zero if successful, else a negative number which is the Idris
error return code, negated.

!item [EXAMPLE] (!nl)
To change a tty speed, with minumum perturbation:
!begin_sourcecode
gtty(fd, &stat);
stat.t_speeds &= ~(T_OSPEED|T_ISPEED);
stat.t_speeds |= ospeed << 8 | ispeed;
stty(fd, &stat);
!end_sourcecode

!item [SEE ALSO] (!nl)
gtty

!end_blist

!end_node

################################################################################

!begin_node sync - synchronize disks with memory
!ignore_index
!label sync
!html_name sync

!begin_blist [NAME]
!item [NAME] (!nl)
sync - synchronize disks with memory

!item [SYNOPSIS] (!nl)
VOID sync()

!item [FUNCTION] (!nl)
sync ensures that all delayed writes are performed by the system, so that
disk integrity is assured before taking the system down. It updates all
inodes that have been modified since the last sync, and writes all data
blocks not correctly represented on open or mounted block special devices.

If a filesystera is to be accessed other than through the block special
file on which it is mounted, sync should first be performed to ensure that
the disk image is current.

!item [RETURNS] (!nl)
Nothing.

!item [EXAMPLE] (!nl)
A simple "sync daemon" is:
!begin_sourcecode
FOREVER
{
    sync();
    sleep(30);
}
!end_sourcecode

!end_blist

!end_node

################################################################################

!begin_node time - get system time
!ignore_index
!label time
!html_name time

!begin_blist [NAME]
!item [NAME] (!nl)
time - get system time

!item [SYNOPSIS] (!nl)
ULONG time()

!item [FUNCTION] (!nl)
time gets the system time, which is the number of seconds since the 1 Jan
1970 epoch.

!item [RETURNS] (!nl)
time returns the system time as a long integer.

!item [EXAMPLE] (!nl)
To backup an hour:
!begin_sourcecode
stime(time() - 60 * 60);
!end_sourcecode

!item [SEE ALSO] (!nl)
stime

!end_blist

!end_node

################################################################################

!begin_node times - get process times
!ignore_index
!label times
!html_name times

!begin_blist [NAME]
!item [NAME] (!nl)
times - get process times

!item [SYNOPSIS] (!nl)
ERROR times(buf) (!nl)
~~~~struct tms *buf;

!item [FUNCTION] (!nl)
times returns the cumulative times consumed by the current process and all
its dead children in the structure pointed at by buf. putime is the user
mode time consumed by the process proper; pstime is its system mode time,
cutime and cstime are the cumulative user and system times consumed by all
the children that have been laid to rest by wait system calls, including
the times of all their children thus interred.

All times are in 1/60 second ticks.

!item [RETURNS] (!nl)
times writes the process times in the structure pointed at by buf.
times returns zero if successful, else a negative number which is the
Idris error return code, negated.

!item [EXAMPLE] (!nl)
!begin_sourcecode
times(&vec);
putfmt("System: %.1f User: %.lfXn", vec.cstime/60.0, vec.cutime/60.0);
!end_sourcecode

!item [SEE ALSO] (!nl)
time

!end_blist

!end_node

################################################################################

!begin_node umount - unmount a filesystem
!ignore_index
!label umount
!html_name umount

!begin_blist [NAME]
!item [NAME] (!nl)
umount - unmount a filesystem

!item [SYNOPSIS] (!nl)
ERROR umount(spec) (!nl)
~~~~TEXT *spec;

!item [FUNCTION] (!nl)
umount disassociates the root of the filesystem written on the block
special device spec with whatever node it was mounted on; henceforth
the filesystem is no longer reachable via the directory tree.

Only the superuser succeeds with this call.

!item [RETURNS] (!nl)
umount returns zero if successful, else a negative number which is the
Idris error return code, negated.

!item [EXAMPLE]
!begin_sourcecode
umount("/dev/rk1");
!end_sourcecode

!item [SEE ALSO] (!nl)
mount

!end_blist

!end_node

################################################################################

# FIXME: real uname() missing

################################################################################

# FIXME: belongs to support library
!begin_node uniqnm - create a unique file name
!ignore_index
!label uniqnm
!html_name uniqnm

!begin_blist [NAME]
!item [NAME] (!nl)
uniqnm - create a unique file name

!item [SYNOPSIS] (!nl)
TEXT *uniqnm()

!item [FUNCTION] (!nl)
uniqnm returns a pointer to the start of a NUL terminated name which is
guaranteed not to conflict with normal user filenames, The name is, in
fact, unique to each Idris process, and may be modified by a suffix, so
that a family of process-unique files may be dealt with, The name may be
used as the first argument to a create, or subsequent open, call, so long
as any such files created are removed before program termination. It is
considered bad manners to leave scratch files lying about.

!item [RETURNS] (!nl)
uniqnm returns the same pointer on every call during a given program
invocation. It takes the form "/tmp/t#####" where ##### is the processid in
octal. The pointer will never be NULL.

!item [EXAMPLE] (!nl)
!begin_sourcecode
if ((fd = create(uniqnm(), WRITE, 1)) < 0)
    putstr(STDERR, "can't create sort temp\n", NULL);
!end_sourcecode

!item [SEE ALSO] (!nl)
close, create, open, remove

!item [BUGS] (!nl)
A program invoked by the exec system call, without a fork, inherits the
Idris processid used to generate unique names. Collisions can occur if
files so named are not meticulously removed.

!end_blist

!end_node

################################################################################

!begin_node unlink - erase link to file
!ignore_index
!label unlink
!html_name unlink

!begin_blist [NAME]
!item [NAME] (!nl)
unlink - erase link to file

!item [SYNOPSIS] (!nl)
ERROR unlink(fname) (!nl)
~~~~TEXT *fname;

!item [FUNCTION] (!nl)
unlink removes the link specified by the file fname. No checks are made
for whether this is a good idea. Only the superuser may unlink a directory.

!item [RETURNS] (!nl)
unlink returns zero if successful else a negative number, which is the
Idris error return code, negated.

!item [EXAMPLE]
!begin_sourcecode
if(!isdir(getmod(file)))
    unlink(file);
!end_sourcecode

!item [SEE ALSO] (!nl)
link, remove

!item [BUGS] (!nl)
A program executing as superuser can scramble a directory structure by
injudicious calls on unlink.

!end_blist

!end_node

################################################################################

!begin_node wait - wait for child to terminate
!ignore_index
!label wait
!html_name wait

!begin_blist [NAME]
!item [NAME] (!nl)
wait - wait for child to terminate

!item [SYNOPSIS] (!nl)
PID wait(pstat) (!nl)
~~~~COUNT *pstat;

!item [FUNCTION] (!nl)
wait suspends execution of the calling program until a child process
terminates, so that it can return the child's termination status at
pstat and its processid as the value of the function. Children remain
in limbo (zombie status, actually) until laid to rest by a waiting
parent.

The status returned contains the number of the terminating signal, if any,
in its less significant byte, and the status reported back by the child's
exit call in its more significant byte. By convention, a status word of
all zeros means normal termination; if (*pstat & 0200) then a core dump
has been made,

!item [RETURNS] (!nl)
wait returns the processid of the child whose status is written at pstat,
if any, else -1 if the caller has no children,

!item [EXAMPLE]
!begin_sourcecode
if (0 < (pid = forkO))
    while (wait(&status) != pid)
        ;
!end_sourcecode

!item [SEE ALSO] (!nl)
fork

!end_blist

!end_node

################################################################################

!begin_node write - write to a file
!ignore_index
!label write
!html_name write

!begin_blist [NAME]
!item [NAME] (!nl)
write - write to a file

!item [SYNOPSIS] (!nl)
COUNT write(fd, buf, size) (!nl)
~~~~FILE fd; (!nl)
~~~~TEXT *buf; (!nl)
~~~~BYTES size;

!item [FUNCTION] (!nl)
write writes size characters starting at buf to the file specified by fd.

!item [RETURNS] (!nl)
If an error occurs, write returns a negative number which is the Idris
error code, negated; otherwise the value returned should be size.

!item [EXAMPLE] (!nl)
To copy a file:
!begin_sourcecode
while (0 < (n = read(STDIN, buf, size)))
    write(STDOUT, buf, n);
!end_sourcecode

!item [SEE ALSO] (!nl)
read

!end_blist

!end_node

################################################################################

!begin_node xecl - execute a file with argument list
!ignore_index
!label xecl
!html_name xecl

!begin_blist [NAME]
!item [NAME] (!nl)
xecl - execute a file with argument list

!item [SYNOPSIS] (!nl)
COUNT xecl(fname, sin, sout, flags, sO, si, ..., NULL) (!nl)
~~~~TEXT *fname; (!nl)
~~~~FILE sin, sout; (!nl)
~~~~COUNT flags; (!nl)
~~~~TEXT *s0, *s1, ...

!item [FUNCTION] (!nl)
xecl invokes the program file fname, connecting its STDIN to sin and
STDOUT to sout and passing it the string arguments s0, si, ... If
(!(flags & 3)) fname is invoked as a new process; xecl will wait until
the command has completed and will return its status to the calling
program. If (flags & 1) fname is invoked as a new process and xecl will
not wait, but will return the processid of the child. If (flags & 2)
fname is invoked in place of the current process, whose image is forever
gone. In this case, xecl will never return to the caller.

To the value of flags may be added a 4 if the processing of interrupt and
quit signals for fname is to revert to system handling. The value of
flags may also be incremented by 8 if the effective userid is to be made
the real userid before fname is executed. If sin is not equal to STDIN,
or if sout is not equal to STDOUT, the file (sin or sout) is closed before
xecl returns.

If fname does not contain a '/', then xecl will search an arbitrary series
of directories for the file specified, by prepending to fname each path
specified by the global variable _paths before trying to execute it.
_paths is of type pointer to TEXT, and points to a NUL terminated series
of directory paths separated by '|'s.

If the file eventually found has execute permission, but is not in
executable format, /bin/sh is invoked with the current prefixed version
of fname as its first argument and, following fname, an argument vector
composed of s0, si, ...

!item [RETURNS] (!nl)
If fname cannot be invoked, xecl will fail. If (!(flags & 3)) xecl
returns YES if the command executed successfully, otherwise NO; if
(flags & 1) xecl returns the id of the child process, if one exists,
otherwise zero; if (flags & 2) xecl will never return to the caller.

In all cases, if fname cannot be executed, an appropriate error message
is written to STDERR.

!item [EXAMPLE]
!begin_sourcecode
if (!xecl(pgm, STDIN, create(file, WRITE), 0, f1, f2, NULL))
    putstr(STDERR, pgm, " failed\n", NULL);
!end_sourcecode

!item [SEE ALSO] (!nl)
xecv

!end_blist

!end_node

################################################################################

!begin_node xecv - execute a file with argument vector
!ignore_index
!label xecv
!html_name xecv

!begin_blist [NAME]
!item [NAME] (!nl)
xecv - execute a file with argument vector

!item [SYNOPSIS] (!nl)
COUNT xecv(fname, sin, scut, flags, av) (!nl)
~~~~TEXT *fname;
~~~~FILE sin, sout; (!nl)
~~~~COUNT flags; (!nl)
~~~~TEXT **av;

!item [FUNCTION] (!nl)
xecv invokes the program file fname, connecting its STDIN to sin and
STDOUT to sout and passing it the string arguments specified in the NULL
terminated vector av. Its behavior is otherwise identical to xecl.

!item [SEE ALSO] (!nl)
xecl

!end_blist

!end_node

################################################################################

# template for copy/paste
!if 0

!begin_node xx
!ignore_index
!label x
!html_name x

!begin_blist [NAME]
!item [NAME] (!nl)
chmod - change mode of file

!item [SYNOPSIS] (!nl)
ERROR x() (!nl)
~~~~TEXT *fname;

!item [FUNCTION] (!nl)

!item [RETURNS] (!nl)

!item [EXAMPLE] (!nl)
!begin_sourcecode
!end_sourcecode

!item [SEE ALSO] (!nl)
chmod, close, create, open, remove, uniqnm

!end_blist

!end_node

################################################################################
!endif

!end_node
