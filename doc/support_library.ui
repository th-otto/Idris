!begin_node IDRIS Support Library
!html_name support_library

!begin_blist [NAME]
!item [NAME] (!nl)
Conventions - the Idris support library

!item [SYNOPSIS] (!nl)
/lib/libi*

!item [FUNCTION] (!nl)
The functions documented in this section are kept in a library,
separate from the standard C library, with a name whose prefix is
/lib/libi (and whose suffix is machine dependent). They are used
extensively in the construction of standard Idris utilities, to perform
common functions uniformly and to enforce communication protocols among
utilities. They are thus quite useful to anyone wishing to add
utilities that are to cooperate with the existing community.

Most of the notation used here is the same as in earlier sections of this
manual, but there are a few additional types that creep in from various
header files:

!begin_blist
!item [BLOCK] an unsigned short, capable of holding any filesystem block number.
Block 0 is often taken as the absence of a block number. Defined in/lib/ino.h.

!item [FINOOE] a filesystem inode, possibly as represented on the disk or possibly
in native byte order. Defined in /lib/ino.h.

!item [INUM] an unsigned short, capable of holding any filesystem inode number.
Inode 0 does not exist. Defined in /lib/ino.h.

!item [TVEC] a time vector, used to communicate parsed dates among library functions.
Defined in /lib/time.h as:
!begin_sourcecode
typedef struct {
    BYTES secs; /* seconds [0, 60) */
    BYTES mins; /* minutes [0, 60) */
    BYTES hrs;  /* hours [0, 24) */
    BYTES dmth; /* day of month [1, 31] */
    BYTES mth;  /* month of year [0, 12) */
    BYTES yr;   /* years since 1900 [70, 131) */
    BYTES dwk;  /* day of week, Sunday = 0 [0, 7) */
    BYTES dyr;  /* day of year [0, 365] */
    BOOL dstf;  /* non-zero if daylight savings time */
} TVEC;
!end_sourcecode
!end_blist

Also included in this library is a version of putf (the internal routine
_putf to be exact) that cannot deal with the floating point conversions %d
and %f. This is provided so that utilities can perform formatted output
--- using decode, errfmt, putf, and putfmt --- without dragging in (possibly
extensive) floating point runtime support code that will never be needed.
Be warned, however, that automatically including the Idris support library
with the standard compile and link scripts will lead to puzzling behavior
in a program that expects to perform floating output.

!end_blist

!toc !depth 1

################################################################################

!begin_node _penable - control function entry counts in profiling
!ignore_index
!label _penable
!html_name _penable

!begin_blist [NAME]
!item [NAME] (!nl)
_penable - control function entry counts in profiling

!item [SYNOPSIS] (!nl)
TBOOL _penable;

!item [FUNCTION] (!nl)
_penable is used by the function entry counting routine of the profiling
package, to control whether or not calls to the routine actually will
record function entries. If _penable is non-zero, function entries will
be counted; otherwise, the counting routine returns without doing
anything.

!item [RETURNS] (!nl)
_profil() sets jpenable to 1 just before returning. _proend() clears
_penable just after being called.

!item [SEE ALSO] (!nl)
_proend, _profil

!end_blist

!end_node

################################################################################

!begin_node _proend - end profiling
!ignore_index
!label _proend
!html_name _proend

!begin_blist [NAME]
!item [NAME] (!nl)
_proend - end profiling

!item [SYNOPSIS] (!nl)
VOID (*_proend())()

!item [FUNCTION] (!nl)
_proend terminates profiling, by clearing the one-byte flag _penable to
disable function entry counting, calling profilO to end time profiling,
and writing out the time profiling and entry count buffers to the file
named in the last preceding call to _profil().

!item [RETURNS] (!nl)
Since _proend() is linked into the chain of programs to be called on
program exit or interrupt, it returns the address of the next one to call.

!item [SEE ALSO] (!nl)
_penable, _profil

!end_blist

!end_node

################################################################################

!begin_node _profil - start profiling
!ignore_index
!label _profil
!html_name _profil

!begin_blist [NAME]
!item [NAME] (!nl)
_profil - start profiling

!item [SYNOPSIS] (!nl)
TEXT *_profil(p) (!nl)
~~~~struct _prof *p;

!item [FUNCTION] (!nl)
_profil performs a number of useful housekeeping functions preparatory to
commencing program profiling. Its single argument, p, is a pointer to a
standard profile file header, which is immediately followed by the name of
the file to be generated by _proend().

_profil computes file header parameters psize and scale, allocates space
for the time profiling and entry count buffers at pbuf, calls profil() to
initiate time profiling, and ensures that _proend() is called on program
interrupt or exit. Finally, it enables function entry counting by setting
the one-byte flag _penable to 1.

!item [RETURNS] (!nl)
_profil returns the address of the first byte past the end of the buffer
space it allocated at pbuf.

!item [SEE ALSO] (!nl)
__penable, _proend

!end_blist

!end_node

################################################################################

!begin_node askpw - ask for a password
!ignore_index
!label askpw
!html_name askpw

!begin_blist [NAME]
!item [NAME] (!nl)
askpw - ask for a password

!item [SYNOPSIS] (!nl)
TEXT *askpw(kbuf, key) (!nl)
~~~~TINY kbuf[8]; (!nl)
~~~~TEXT *key;

!item [FUNCTION] (!nl)
askpw fills kbuf with the NUL terminated password at key, or if (key ==
NULL) reads a line from STOIN to fill kbuf. Before reading a line from a
terminal as STDIN, askpw will drain outstanding input by performing an
stty, prompt with the string "\7password:\ " and accept the subsequent
line, echoing only the trailing newline.

In any case, the first eight characters of the password are used; a short
string is padded on the right with NULs.

Note that a password may thus be obtained from any of three sources:
from an argument to the function, from a terminal with prompting and
with printing suppressed, or from a noninteractive STDIN with no
prompting.

!item [RETURNS] (!nl)
askpw returns the address of kbuf, which contains the NUL padded password.

!item [EXAMPLE]
!begin_sourcecode
bldks(ks, askpw(kbuf, NULL));
!end_sourcecode

!item [SEE ALSO] (!nl)
codepw

!end_blist

!end_node

################################################################################

!begin_node asure - get user response to question
!ignore_index
!label asure
!html_name asure

!begin_blist [NAME]
!item [NAME] (!nl)
asure - get user response to question

!item [SYNOPSIS] (!nl)
BOOL asure(p) (!nl)
~~~~TEXT *p;

!item [FUNCTION] (!nl)
If STDIN looks like a terminal, asure drains its input by performing an
stty, writes the NUL terminated string at *p to STDERR, followed by a
space, then reads up to 32 characters from STDIN.

This meticulous sequence of events is useful when a program needs to be
assured that a conscious human accomplice is present.

!item [RETURNS] (!nl)
If the line read begins with a 'y' or 'Y', or if STDIN is not a terminal,
asure returns YES; otherwise it returns NO.

!item [EXAMPLE]
!begin_sourcecode
if (asure("are you sure?"))
    scrog();
!end_sourcecode

!end_blist

!end_node

################################################################################

!begin_node atime - convert time vector to ASCII string
!ignore_index
!label atime
!html_name atime

!begin_blist [NAME]
!item [NAME] (!nl)
atime - convert time vector to ASCII string

!item [SYNOPSIS] (!nl)
TEXT *atime(vt, s) (!nl)
~~~~TVEC *vt; (!nl)
~~~~TEXT *s;

!item [FUNCTION] (!nl)
atime converts the time vector at vt to a 24 character string at s, having
the form:
!begin_center
Thu Aug 12 09:53:12 1980
!end_center

There is no terminating NUL or newline.

!item [RETURNS] (!nl)
atime writes the date in ASCII at s[0] through s[23], and returns s.

!item [EXAMPLE] (!nl)
To print the date:
!begin_sourcecode
IMPORT LONG time();
IMPORT TEXT *_est, *edt;
INTERN TEXT buf[] {"012345678901234567890123 "};
TVEC tvec;
ltime(&tvec, time(NULL));
putstr(STDOUT, atime(&tvec, buf), tvec.dstf ? _edt : _est, "\n", NULL);
!end_sourcecode

!item [SEE ALSO] (!nl)
ltime, vtime

!end_blist

!end_node

################################################################################

# template for copy/paste
!if 0

!begin_node xx
!ignore_index
!label x
!html_name x

!begin_blist [NAME]
!item [NAME] (!nl)

!item [SYNOPSIS] (!nl)
ERROR x() (!nl)
~~~~TEXT *fname;

!item [FUNCTION] (!nl)

!item [RETURNS] (!nl)

!item [EXAMPLE] (!nl)
!begin_sourcecode
!end_sourcecode

!item [SEE ALSO] (!nl)


!end_blist

!end_node

################################################################################
!endif

!end_node

